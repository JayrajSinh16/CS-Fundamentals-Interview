# Query Optimization

Query optimization is the process of improving database query performance through various techniques including index usage, query rewriting, and execution plan analysis. It's crucial for maintaining application performance as data grows.

## Key Points

- **Execution Plan**: Database's strategy for executing a query, showing steps and costs. Generated by query optimizer based on available indexes and statistics. Can be analyzed to identify performance bottlenecks and optimization opportunities. Essential tool for understanding query performance characteristics.
- **Cost-based Optimization**: Database chooses lowest-cost execution path based on estimated resource usage. Considers CPU, I/O, and memory costs for different execution strategies. Uses table statistics and index information for accurate cost estimation. Modern approach used by most commercial database systems.
- **Index Usage**: Proper indexes can dramatically improve performance by avoiding full table scans. Query optimizer automatically chooses best indexes when available. Index design should match common query patterns and WHERE clause conditions. Missing indexes are often primary cause of poor query performance.
- **Query Rewriting**: Restructuring queries for better performance without changing results. Includes techniques like predicate pushdown, join reordering, and subquery transformation. Can be done manually by developers or automatically by optimizer. Often provides significant performance improvements with minimal effort.
- **Statistics**: Database uses table/column statistics for optimization decisions and cardinality estimation. Include row counts, data distribution, and index selectivity information. Must be kept current through regular updates for optimal performance. Outdated statistics can lead to poor execution plan choices.
- **Avoid**: SELECT *, unnecessary JOINs, functions in WHERE clause, leading wildcards in LIKE. These patterns prevent efficient index usage and increase query costs. Simple changes in query structure can often provide dramatic performance improvements.

## Example

```sql
-- BEFORE: Poorly optimized queries
-- Full table scan due to function in WHERE
SELECT * FROM employees WHERE YEAR(hire_date) = 2023;

-- No index usage due to leading wildcard
SELECT * FROM employees WHERE name LIKE '%John%';

-- Unnecessary SELECT *
SELECT * FROM employees e JOIN departments d ON e.dept_id = d.id 
WHERE d.name = 'Engineering';

-- AFTER: Optimized queries
-- Use index on hire_date with range
SELECT employee_id, name, hire_date FROM employees 
WHERE hire_date >= '2023-01-01' AND hire_date < '2024-01-01';

-- Use index with proper LIKE pattern
SELECT employee_id, name FROM employees WHERE name LIKE 'John%';

-- Select only needed columns
SELECT e.employee_id, e.name, d.name as department 
FROM employees e 
JOIN departments d ON e.dept_id = d.id 
WHERE d.name = 'Engineering';

-- Use EXISTS instead of IN for better performance
SELECT c.customer_id, c.name 
FROM customers c 
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);
```

**Explanation**: Optimized queries use indexes effectively, avoid functions in WHERE clauses, select only necessary columns, and use appropriate JOIN techniques.

## Common Interview Questions

### Q1: How do you identify slow queries that need optimization?
**Answer**: 
- **Query execution time**: Monitor queries taking longer than expected
- **Execution plans**: Analyze plans for table scans, high costs
- **Database monitoring tools**: Use built-in tools (MySQL slow query log, SQL Server Profiler)
- **Performance counters**: CPU usage, I/O waits, lock waits
- **Application Performance Monitoring (APM)**: Tools like New Relic, DataDog

### Q2: What's the difference between table scan and index seek?
**Answer**:
- **Table Scan**: Reads every row in the table sequentially (slow, high I/O)
- **Index Seek**: Uses index to jump directly to relevant rows (fast, low I/O)
```sql
-- Causes table scan (no index on salary)
SELECT * FROM employees WHERE salary > 50000;

-- Causes index seek (with index on salary)
CREATE INDEX idx_salary ON employees(salary);
SELECT * FROM employees WHERE salary > 50000; -- Now uses index seek
```

### Q3: Why should you avoid using functions in WHERE clauses?
**Answer**: Functions prevent index usage because the database can't use the index on the original column:
```sql
-- Bad: Function prevents index usage
SELECT * FROM employees WHERE UPPER(last_name) = 'SMITH';

-- Good: Use functional index or rewrite query
CREATE INDEX idx_upper_lastname ON employees(UPPER(last_name)); -- Functional index
-- OR
SELECT * FROM employees WHERE last_name = 'Smith'; -- Assume proper case
```

### Q4: How do database statistics affect query optimization?
**Answer**: Database statistics help the optimizer choose the best execution plan:
- **Cardinality**: Number of distinct values in columns
- **Distribution**: How values are distributed across ranges
- **Table size**: Number of rows in tables
- **Index selectivity**: How well indexes filter data

Outdated statistics can lead to poor execution plans, so regular updates are crucial.

### Q5: What's the impact of query hints and when should you use them?
**Answer**: Query hints force the optimizer to use specific strategies:
```sql
-- Force index usage
SELECT * FROM employees WITH (INDEX(idx_salary)) WHERE salary > 50000;

-- Force join algorithm
SELECT * FROM employees e INNER HASH JOIN departments d ON e.dept_id = d.id;
```
**Use sparingly**: Only when you know better than the optimizer, and always test thoroughly. Hints can become outdated as data changes.

---
[‚Üê Back to Main Guide](./README.md)
